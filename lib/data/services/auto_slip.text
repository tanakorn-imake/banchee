
// lib/data/services/auto_slip_manager.dart

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:photo_manager/photo_manager.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';
import 'package:flutter_tesseract_ocr/flutter_tesseract_ocr.dart';

import '../models/transaction_model.dart';
import 'database_helper.dart';

class SlipCandidate {
  final AssetEntity asset;
  final String bankName;

  SlipCandidate({required this.asset, required this.bankName});
}

class AutoSlipManager {
  static const String _prefLastCheckKey = "last_slip_auto_scan_time";

  // Mapping ‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏° -> ‡∏ä‡∏∑‡πà‡∏≠‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£
  static const Map<String, String> _bankMapping = {
    "K PLUS": "KBank",
    "SCB EASY": "SCB",
    "Krungthai NEXT": "KTB",
    "BualuangM": "BBL",
    "KMA": "Krungsri",
    "ttb touch": "TTB",
    "MyMo": "GSB",
  };

  final DatabaseHelper _dbHelper = DatabaseHelper.instance;

  Future<List<SlipCandidate>> scanForNewSlips() async {
    final PermissionState ps = await PhotoManager.requestPermissionExtend();
    if (!ps.isAuth && ps != PermissionState.limited) return [];

    //DateTime checkSince = DateTime(2025, 1, 1);

    //  ‡∏ñ‡πâ‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏•‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏ó‡∏ô
     final prefs = await SharedPreferences.getInstance();
     int lastCheckTime = prefs.getInt(_prefLastCheckKey) ?? DateTime.now().millisecondsSinceEpoch;
     DateTime checkSince = DateTime.fromMillisecondsSinceEpoch(lastCheckTime);

    List<SlipCandidate> foundSlips = [];
    final List<AssetPathEntity> albums = await PhotoManager.getAssetPathList(type: RequestType.image);

    for (var album in albums) {
      if (_bankMapping.containsKey(album.name)) {
        final List<AssetEntity> photos = await album.getAssetListRange(start: 0, end: 100);
        for (var photo in photos) {
          if (photo.createDateTime.isAfter(checkSince)) {
            foundSlips.add(SlipCandidate(asset: photo, bankName: _bankMapping[album.name]!));
          }
        }
      }
    }

    foundSlips.sort((a, b) => a.asset.createDateTime.compareTo(b.asset.createDateTime));
    return foundSlips;
  }

  // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏° parameter onProgress ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤ UI
  Future<int> processAndSaveSlips(List<SlipCandidate> slips, {Function(int current, int total)? onProgress}) async {
    if (slips.isEmpty) return 0;

    final prefs = await SharedPreferences.getInstance();
    final String deviceId = prefs.getString('device_id') ?? 'unknown_device';
    final String payerName = prefs.getString('user_name') ?? 'Me';

    int savedCount = 0;
    int current = 0;

    for (var slip in slips) {
      current++;
      // ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏∑‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
      if (onProgress != null) onProgress(current, slips.length);

      try {
        final File? file = await slip.asset.file;
        if (file != null) {
          debugPrint("üìå [Process] Reading Slip (${slip.bankName})");
          if (await _isDuplicate(file.path, slip.asset.createDateTime)) {
            debugPrint("‚ö†Ô∏è Skip duplicate: ${slip.asset.id}");
            continue;
          }
          // 1. OCR Extraction
          String rawText = await FlutterTesseractOcr.extractText(
            file.path,
            language: 'tha+eng',
            args: {"psm": "4", "preserve_interword_spaces": "1"},
          );

          // 2. Pre-process text
          String cleanText = _cleanOcrText(rawText);

          // 3. Extract Data
          double? amount = _extractAmount(cleanText, slip.bankName);
          String? recipient = _extractRecipient(cleanText, slip.bankName, payerName);

          debugPrint("üí∞ Amount: $amount | üë§ Recipient: $recipient");

          if (amount != null) {

            // üî• SMART LOGIC (‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà: ‡∏à‡∏≥‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡πÑ‡∏°‡πà‡πÄ‡∏ä‡πá‡∏Ñ‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á) üî•
            String category = "‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢"; // Default ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏Ñ‡∏¢‡πÇ‡∏≠‡∏ô‡πÉ‡∏´‡πâ‡∏Ñ‡∏ô‡∏ô‡∏µ‡πâ
            String? tag;

            if (recipient != null) {
              // ‡πÑ‡∏õ‡∏Ñ‡πâ‡∏ô‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏Ñ‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏≤‡πÄ‡∏Ñ‡∏¢‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡∏≠‡∏∞‡πÑ‡∏£‡πÑ‡∏ß‡πâ
              final history = await _dbHelper.getLastMappingByRecipient(recipient);

              if (history['category'] != null) {
                category = history['category']!; // ‡πÉ‡∏ä‡πâ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏•‡∏¢
                tag = history['tag'];
                debugPrint("ü§ñ Smart Memory: Found history for $recipient -> $category");
              }
            }
            // üî• END SMART LOGIC üî•

            final newTxn = TransactionModel(
              id: const Uuid().v4(),
              amount: amount,
              date: slip.asset.createDateTime,
              category: category,
              note: recipient != null
                  ? "‡πÇ‡∏≠‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á $recipient (${slip.bankName})"
                  : "Auto-scan (${slip.bankName})",
              recipientName: recipient,
              receiptPath: file.path,
              tag: tag, // ‡πÉ‡∏™‡πà Tag ‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÑ‡∏î‡πâ
              payerName: payerName,
              deviceId: deviceId,
              isSplitBill: false,
              isSynced: false,
              isDeleted: false,
            );

            await _dbHelper.createTransaction(newTxn);
            savedCount++;
          }
        }
      } catch (e) {
        debugPrint("‚ùå Error processing slip: $e");
        continue;
      }
    }

    await prefs.setInt(_prefLastCheckKey, DateTime.now().millisecondsSinceEpoch);
    return savedCount;
  }

  // ---------------------------------------------------------------------------
  // üßπ Text Cleaning
  // ---------------------------------------------------------------------------
  String _cleanOcrText(String text) {
    String t = text;
    t = t.replaceAll('|', '')
        .replaceAll('L:', '')
        .replaceAll('¬©', '')
        .replaceAll('¬Æ', '')
        .replaceAll('‡∏£‡∏´‡∏±‡∏™‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á', '')
        .replaceAll('‡∏à‡πç‡∏≤‡∏ô‡∏ß‡∏ô', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô');

    t = t.replaceAll('‡∏ö‡∏≤‡∏¢', '‡∏ô‡∏≤‡∏¢')
        .replaceAll('suns', '‡∏ô‡∏≤‡∏¢')
        .replaceAll('uuns', '‡∏ô‡∏≤‡∏¢')
        .replaceAll('‡∏ô.‡∏™.', '‡∏ô.‡∏™. ');

    t = t.replaceAll('in (0)', '‡πÑ‡∏õ‡∏ó‡∏µ‡πà')
        .replaceAll('un (0)', '‡πÑ‡∏õ‡∏ó‡∏µ‡πà')
        .replaceAll('1n (0)', '‡πÑ‡∏õ‡∏ó‡∏µ‡πà');

    return t;
  }
  Future<bool> _isDuplicate(String filePath, DateTime date) async {
    final db = await _dbHelper.database;

    // 1. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å Path (‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡πä‡∏∞‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏°)
    final List<Map<String, dynamic>> resPath = await db.query(
      'transactions',
      columns: ['id'],
      where: 'receiptPath = ? AND isDeleted = 0',
      whereArgs: [filePath],
      limit: 1,
    );
    if (resPath.isNotEmpty) return true;

    // 2. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡∏•‡∏≤ (‡∏Å‡∏±‡∏ô‡πÄ‡∏´‡∏ô‡∏µ‡∏¢‡∏ß‡∏ñ‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡∏π‡∏Å‡∏¢‡πâ‡∏≤‡∏¢/‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠)
    // ‡πÉ‡∏ä‡πâ string ISO ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÉ‡∏ô DB ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ä‡πâ TEXT
    final String dateStr = date.toIso8601String();
    final List<Map<String, dynamic>> resTime = await db.query(
      'transactions',
      columns: ['id'],
      where: 'date = ? AND isDeleted = 0',
      whereArgs: [dateStr],
      limit: 1,
    );
    return resTime.isNotEmpty;
  }
  // ---------------------------------------------------------------------------
  // üí∞ Amount Extraction
  // ---------------------------------------------------------------------------
  double? _extractAmount(String text, String bankName) {
    List<String> lines = text.split('\n');
    final amountRegex = RegExp(r'[\d,]+\.\d{2}'); // ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏° 2 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á

    double? bestAmount;

    for (var line in lines) {
      // 1. ‡∏Å‡∏£‡∏≠‡∏á‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏¢‡∏≠‡∏î‡πÇ‡∏≠‡∏ô‡∏≠‡∏≠‡∏Å‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡∏ï‡∏±‡∏î‡∏¢‡∏≠‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠)
      if (line.contains('‡∏Ñ‡πà‡∏≤‡∏ò‡∏£‡∏£‡∏°‡πÄ‡∏ô‡∏µ‡∏¢‡∏°') || line.contains('Fee') ||
          line.contains('Balance') || line.contains('‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠') ||
          line.contains('‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏¢‡πå ID')) {
        continue;
      }

      // 2. ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°
      if (line.contains('‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà') || line.contains('Date') || line.contains('Time')) {
        continue;
      }

      Iterable<RegExpMatch> matches = amountRegex.allMatches(line);
      for (var match in matches) {
        String cleanNum = match.group(0)!.replaceAll(',', '');
        double? val = double.tryParse(cleanNum);

        if (val != null && val > 0.00) {
          // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô/Amount ‡πÉ‡∏´‡πâ‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡πÄ‡∏•‡∏¢‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πà
          if (line.contains('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô') || line.contains('Amount') || line.contains('‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô')) {
            return val;
          }
          // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ Keyword ‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô
          if (bestAmount == null) {
            bestAmount = val;
          }
        }
      }
    }
    return bestAmount;
  }

  // ---------------------------------------------------------------------------
  // üë§ Recipient Extraction
  // ---------------------------------------------------------------------------
  String? _extractRecipient(String text, String bankName, String payerName) {
    List<String> lines = text.split('\n').map((e) => e.trim()).where((e) => e.isNotEmpty).toList();

    // Strategy A: Keyword
    List<String> targetKeywords = ['‡πÑ‡∏õ‡∏¢‡∏±‡∏á', '‡πÑ‡∏õ‡∏ó‡∏µ‡πà', '‡∏ñ‡∏∂‡∏á', 'To', '‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô', '‡πÇ‡∏≠‡∏ô‡πÑ‡∏õ', '‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô'];

    for (int i = 0; i < lines.length; i++) {
      for (var kw in targetKeywords) {
        if (lines[i].contains(kw)) {
          String sameLineParams = lines[i].replaceAll(kw, '').trim();
          if (_isValidName(sameLineParams)) return _cleanName(sameLineParams);

          if (i + 1 < lines.length) {
            String nextLine = lines[i+1];
            if (_isBankName(nextLine) && i + 2 < lines.length) {
              return _cleanName(lines[i+2]);
            }
            if (_isValidName(nextLine)) return _cleanName(nextLine);
          }
        }
      }
    }

    // Strategy B: Positional (Prefix) - ‡πÉ‡∏ä‡πâ _isSelf ‡πÅ‡∏¢‡∏Å‡πÅ‡∏¢‡∏∞‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏≤
    List<String> nameCandidates = [];
    List<String> prefixes = ['‡∏ô‡∏≤‡∏¢', '‡∏ô‡∏≤‡∏á', '‡∏ô.‡∏™', '‡∏î.‡∏ä.', '‡∏î.‡∏ç.', 'Mr', 'Mrs', 'Miss', 'Ms'];

    for (var line in lines) {
      for (var prefix in prefixes) {
        if (line.startsWith(prefix) || line.contains(" $prefix")) {
          if (!_isBankName(line)) {
            nameCandidates.add(line);
            break;
          }
        }
      }
    }

    if (nameCandidates.length >= 2) {
      if (_isSelf(nameCandidates[0], payerName)) {
        return _cleanName(nameCandidates[1]);
      }
      return _cleanName(nameCandidates.last);
    }
    else if (nameCandidates.length == 1) {
      if (!_isSelf(nameCandidates[0], payerName)) {
        return _cleanName(nameCandidates[0]);
      }
    }

    return null;
  }

  // ---------------------------------------------------------------------------
  // üõ† Helpers
  // ---------------------------------------------------------------------------

  bool _isValidName(String text) {
    if (text.length < 3) return false;
    int digitCount = text.replaceAll(RegExp(r'[^0-9]'), '').length;
    if (digitCount > 3) return false;
    return text.contains(RegExp(r'[‡∏Å-‡πôa-zA-Z]'));
  }

  bool _isBankName(String text) {
    List<String> banks = ['‡∏Å‡∏™‡∏¥‡∏Å‡∏£', '‡πÑ‡∏ó‡∏¢‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå', '‡∏Å‡∏£‡∏∏‡∏á‡πÑ‡∏ó‡∏¢', '‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û', '‡∏Å‡∏£‡∏∏‡∏á‡∏®‡∏£‡∏µ', '‡∏≠‡∏≠‡∏°‡∏™‡∏¥‡∏ô', 'Bank', 'KBank', 'SCB', 'BBL', 'KTB', 'GSB', 'ttb'];
    for (var b in banks) {
      if (text.toLowerCase().contains(b.toLowerCase())) return true;
    }
    return false;
  }

  bool _isSelf(String extractedName, String payerName) {
    String c1 = extractedName.replaceAll(RegExp(r'\s'), '');
    String c2 = payerName.replaceAll(RegExp(r'\s'), '');
    return c1.contains(c2) || c2.contains(c1);
  }

  String _cleanName(String name) {
    String cleaned = name.replaceAll(RegExp(r'[0-9xX\*\-]'), '')
        .replaceAll('un (0)', '')
        .replaceAll('(', '')
        .replaceAll(')', '')
        .replaceAll(RegExp(r'\s+'), ' ')
        .trim();
    return cleaned;
  }
}